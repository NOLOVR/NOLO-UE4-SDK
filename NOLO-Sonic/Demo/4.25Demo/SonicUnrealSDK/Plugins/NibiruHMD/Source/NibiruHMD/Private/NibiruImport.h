// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "Engine.h"
#include <string>
#if PLATFORM_ANDROID
#include <cstring>
#include <dlfcn.h>
#include <stdbool.h>
#include <stdint.h>
#if defined( ANDROID )
#include <jni.h>
#elif defined( __cplusplus )
typedef struct _JNIEnv JNIEnv;
typedef struct _JavaVM JavaVM;
typedef class _jobject * jobject;
typedef class _jstring*   jstring;
#else
typedef const struct JNINativeInterface * JNIEnv;
typedef const struct JNIInvokeInterface * JavaVM;
void * jobject;
#endif


#define NIBIRU_RUNTIME_VERSION(major, minor, revision)  ((((major) & 0xff) << 16) | (((minor) & 0xff) << 8) | ((revision) & 0xff))

#define NIB_KEY_MESH_X "key_mesh_x" // 畸变网格格式
#define NIB_KEY_MESH_Y "key_mesh_y"
#define NIB_KEY_SMALL_TEXTUTRE_SIZE "small_texture_size" // 纹理大小
#define NIB_KEY_ENABLE_POINT "enable_point"  // 白点显示
#define NIB_KEY_BEGIN_FRAME_NUM "begin_frame_num"
#define NIB_KEY_POINT_Z "point_z" // 白点z距离
#
/// An enum for the left and right eye.
typedef enum {
	NVR_LEFT_EYE = 0,
	NVR_RIGHT_EYE,
	NVR_NUM_EYES
} nvr_eye;

/// @}

/// Version information for the Nibiru VR API.
typedef struct nvr_version_ {
	int32_t major;
	int32_t minor;
	int32_t patch;
} nvr_version;

/// An integral 2D size. Used for render target sizes.
typedef struct nvr_sizei {
	int32_t width;
	int32_t height;
} nvr_sizei;

/// An integral 2D rect. Used for window bounds in pixels.
typedef struct nvr_recti {
	int32_t left;
	int32_t right;
	int32_t bottom;
	int32_t top;
} nvr_recti;

/// A floating point 2D rect. Used for field of view, and also for ranges
/// in texture space. When used for a field of view, all angles are in positive
/// degrees from the optical axis.
typedef struct nvr_rectf {
	float left;
	float right;
	float bottom;
	float top;
} nvr_rectf;

///
typedef struct nvr_init_info {
	int sdk_version;
	int init_result;
	int mesh_x;
	int mesh_y;
	int extraIParam;
	float extraFParam;
	char *extraData;
} nvr_init_info;

/// A floating point 2D vector.
typedef struct nvr_vec2f {
	float x;
	float y;
} nvr_vec2f;

/// A floating point 3D vector.
typedef struct nvr_vec3f {
	float x;
	float y;
	float z;
} nvr_vec3f;

/// A floating point 4x4 matrix.
typedef struct nvr_mat4f { float m[4][4]; } nvr_mat4f;

/// A floating point quaternion, in JPL format.
/// We use this simple struct in order not to impose a dependency on a
/// particular math library. The user of this API is free to encapsulate this
/// into any math library they want.
typedef struct nvr_quatf {
	/// qx, qy, qz are the vector component.
	float qx;
	float qy;
	float qz;
	/// qw is the linelar component.
	float qw;
} nvr_quatf;

/// A *monotonic system time* representation. On Android, this is equivalent to
/// System.nanoTime(), or clock_gettime(CLOCK_MONOTONIC). If there is any doubt
/// about how to get the current time for the current platform, simply use
/// gvr_get_time_point_now().
typedef struct nvr_clock_time_point {
	int64_t monotonic_system_time_nanos;
} nvr_clock_time_point;

/// A structure that ties together a region of a buffer, the field of view
/// rendered into that region and a target eye index to define part of the
/// user's field of view. The SDK implementation uses this information to
/// transform the images generated by the app output into the final display that
/// is sent to the screen.
///
/// A set of these structures will most often be generated by the API, via
/// nvr_get_recommended_buffer_viewports() or
/// nvr_get_screen_buffer_viewports(). However, the client may also customize
/// these values via nvr_buffer_viewport_list_set(), constructing a custom
/// nvr_buffer_viewport_list for use in the distortion pass.
typedef struct nvr_buffer_viewport_ nvr_buffer_viewport;

/// List of buffer viewports that completely specifies how to transform the
/// frame's buffers into the image displayed on the screen.
typedef struct nvr_buffer_viewport_list_ nvr_buffer_viewport_list;

/// Specification of a pixel buffer. A pixel buffer can have color, depth and
/// stencil attachments and mostly corresponds to the OpenGL concept of a
/// framebuffer object. However, since there can be multiple such objects for
/// each frame, we avoid calling them "framebuffers". Pixel buffers which are
/// part of the currently acquired frame are immutable, i.e., they cannot be
/// resized or otherwise reconfigured.
typedef struct nvr_buffer_spec_ nvr_buffer_spec;

/// Swap chain that contains some number of frames. Frames in the swap chain
/// can be unused, in the process of being distorted and presented on the
/// screen, or acquired and being rendered to by the application. The swap chain
/// ensures that the most recent available frame is always shown and that the
/// application never has to wait to render the next frame.
typedef struct nvr_swap_chain_ nvr_swap_chain;

/// A single frame acquired from the swap chain. Each frame is composed of one
/// or more buffers, which are then lens distorted and composited into the final
/// output. Buffers are identified by indices that correspond to the position
/// of their gvr_buffer_spec in the list passed when constructing the swap
/// chain.
typedef struct nvr_frame_ nvr_frame;

/// @addtogroup types
/// @{

/// Constants that represent nvr error codes.
typedef enum {
	NVR_ERROR_NONE = 0,
	NVR_ERROR_CONTROLLER_CREATE_FAILED = 2,
	NVR_ERROR_NO_FRAME_AVAILABLE = 3,
} nvr_error;


/// Valid color formats for swap chain buffers.
typedef enum {
	/// Equivalent to GL_RGBA8
	NVR_COLOR_FORMAT_RGBA_8888 = 0,
	/// Equivalent to GL_RGB565
	NVR_COLOR_FORMAT_RGB_565 = 1,
} nvr_color_format_type;

typedef enum {
	/// No depth or stencil buffer.
	NVR_DEPTH_STENCIL_FORMAT_NONE = 255,
	/// Equivalent to GL_DEPTH_COMPONENT16.
	NVR_DEPTH_STENCIL_FORMAT_DEPTH_16 = 0,
	/// Equivalent to GL_DEPTH_COMPONENT24.
	NVR_DEPTH_STENCIL_FORMAT_DEPTH_24 = 1,
	/// Equivlaent to GL_DEPTH24_STENCIL8.
	NVR_DEPTH_STENCIL_FORMAT_DEPTH_24_STENCIL_8 = 2,
	/// Equivalent to GL_DEPTH_COMPONENT32F.
	NVR_DEPTH_STENCIL_FORMAT_DEPTH_32_F = 3,
	/// Equivalent to GL_DEPTH_32F_STENCIL8.
	NVR_DEPTH_STENCIL_FORMAT_DEPTH_32_F_STENCIL_8 = 4,
	/// Equivalent to GL_STENCIL8.
	NVR_DEPTH_STENCIL_FORMAT_STENCIL_8 = 5,
} nvr_depth_stencil_format_type;

/// Types of asynchronous reprojection.
typedef enum {
	/// Do not reproject.
	NVR_REPROJECTION_NONE = 0,
	/// Reproject in all dimensions.
	NVR_REPROJECTION_FULL = 1,
} nvr_reprojection;

typedef struct
	{
		JavaVM *	Vm;					// Java Virtual Machine
		JNIEnv *	Env;				// Thread specific environment
		jobject		ActivityObject;		// Java activity object
	} nvrJava;


typedef struct
{
	// The Java VM is needed for the time warp thread to create a Java environment.
	// A Java environment is needed to access various system services. The thread
	// that enters VR mode is responsible for attaching and detaching the Java
	// environment. The Java Activity object is needed to get the windowManager,
	// packageName, systemService, etc.
	nvrJava				Java;

	// If not zero, then use this display for asynchronous time warp rendering.
	// Using EGL this is an EGLDisplay.
	unsigned long long	Display;

	// If not zero, then use this window surface for asynchronous time warp rendering.
	// Using EGL this can be the EGLSurface created by the application for the ANativeWindow.
	// Preferrably this is the ANativeWIndow itself (requires VRAPI_MODE_FLAG_NATIVE_WINDOW).
	unsigned long long	WindowSurface;

	// If not zero, then resources from this context will be shared with the asynchronous time warp.
	// Using EGL this is an EGLContext.
	unsigned long long	ShareContext;
} nvrModeParms;

struct NACTION_Controller_Config {
	std::string modelPath;//system/etc/controller/14/
	std::string leftObjPath;
	std::string leftMtlPath;
	std::string leftPngPath;
	std::string rightObjPath;
	std::string rightMtlPath;
	std::string rightPngPath;
	float modelPosition[3];
	float modelRotation[3];
	float modelScale[3];
	float batteryPosition[3];
	float batteryRotation[3];
	float batteryScale[3];
	float rayStartPosition[3];
	float rayEndPosition[3];
};

enum nvr_controller_type {
    NVR_CONTROLLER_HAND_LEFT = 0,//左手
    NVR_CONTROLLER_HAND_RIGHT,//右手
    NVR_CONTROLLER_HEAD
};

enum nvr_keycode {
    NVR_ACTION_MOVE = 2,
    NVR_ACTION_UP = 1,
    NVR_ACTION_DOWN = 0,
    NVR_KEYCODE_DPAD_UP = 19,
    NVR_KEYCODE_DPAD_DOWN = 20,
    NVR_KEYCODE_DPAD_LEFT = 21,
    NVR_KEYCODE_DPAD_RIGHT = 22,
    NVR_KEYCODE_DPAD_CENTER = 23,
    NVR_KEYCODE_VOLUME_UP = 24,
    NVR_KEYCODE_VOLUME_DOWN = 25,
    NVR_KEYCODE_BUTTON_Y = 100,
    NVR_KEYCODE_BUTTON_B = 97,
    NVR_KEYCODE_BUTTON_X = 99,
    NVR_KEYCODE_BUTTON_A = 96,
    NVR_KEYCODE_BUTTON_L1 = 102,
    NVR_KEYCODE_BUTTON_R1 = 103,
    NVR_KEYCODE_BUTTON_L2 = 104,
    NVR_KEYCODE_BUTTON_R2 = 105,
    NVR_KEYCODE_BUTTON_THUMBL = 106,
    NVR_KEYCODE_BUTTON_THUMBR = 107,
    NVR_KEYCODE_BUTTON_START = 108,
    NVR_KEYCODE_BUTTON_SELECT = 109,
    NVR_KEYCODE_BUTTON_NIBIRU = 110,
    NVR_KEYCODE_BUTTON_HOME = 3,
    NVR_KEYCODE_BUTTON_APP = 255,
	// NOLO
    NVR_KEYCODE_NOLO_TRIGGER = 103,
    NVR_KEYCODE_NOLO_TOUCH_PAD = 23,
    NVR_KEYCODE_NOLO_GRIP = 109,
    NVR_KEYCODE_NOLO_MENU = 110,
    NVR_KEYCODE_NOLO_BACK = 255,
	// NOLO

	// 3DOF
	NVR_KEYCODE_CONTROLLER_TOUCHPAD_TOUCH = 254,
	NVR_KEYCODE_CONTROLLER_TRIGGER = 103,
	NVR_KEYCODE_CONTROLLER_MENU = 255,
	NVR_KEYCODE_CONTROLLER_TOUCHPAD = 23,
	NVR_KEYCODE_CONTROLLER_VOLUMN_DOWN = 25,
	NVR_KEYCODE_CONTROLLER_VOLUMN_UP = 24
	// 3DOF

};

enum ControllerConnectionState
{
	CONNECTED, DISCONNECTED
};

enum NACTION_CONTROLLER_TYPE {
	CONTROL_NONE = 0,//无指定类型
	CONTROL_6DOF,//6DOF手柄
	CONTROL_3DOF,//3DOF手柄
};
/// @}

typedef nvr_init_info (*API_NibiruInit)(int pluginVersion, long pointer, const nvrModeParms * parms);
typedef nvr_mat4f (*API_NibiruGetSensorData)(int* num);
typedef nvr_mat4f (*API_NibiruGetSensorDataWithPosition)(int* num, float* position);
typedef void (*API_NibiruGetNVRConfig)(float* profile);
typedef void(*API_NibiruResetHeadPose)();
typedef void(*API_NibiruLockHeadPose)();
typedef void(*API_NibiruUnLockHeadPose)();
typedef void(*API_NibiruEnterVRMode)(const nvrModeParms * params);
typedef void(*API_NibiruLeaveVRMode)();
typedef void(*API_NibiruDestory)();

typedef float(*API_NibiruGetFloatValue)(const char * property_name, float default_value);
typedef bool(*API_NibiruSetFloatValue)(const char * property_name, float value);

typedef int(*API_NibiruGetIntValue)(const char * property_name, int default_value);
typedef bool(*API_NibiruSetIntValue)(const char * property_name, int value);

typedef char* (*API_NibiruGetParameter)(const char * property_name);
typedef bool (*API_NibiruSetPatameter)(const char * property_name, char* default_data);

typedef void(*API_NibiruComputeDistortedPoint)(const int32_t eye, const nvr_vec2f uv_in, nvr_vec2f uv_out[3]);
typedef void(*API_NibiruCreateTextures)(int* ids);
typedef bool(*API_NibiruSetTexture)(void * texture, int viewNum);

// 手柄接口
// hand代表左/右手，hand=0->左手，hand=1->右手，float数组为长度为4的四元数+长度为3的位移
typedef void (*API_NibiruController_GetRotPos)(nvr_controller_type hand, float *dest, int length);
typedef bool (*API_NibiruController_IsTouchDown)(nvr_controller_type handType);
typedef bool (*API_NibiruController_IsTouchUp)(nvr_controller_type handType);
typedef bool (*API_NibiruController_IsTouchPressed)(nvr_controller_type handType);
typedef void (*API_NibiruController_GetTouchPosition)(nvr_controller_type handType, nvr_vec2f &position);
typedef bool (*API_NibiruController_IsButtonDown)(nvr_controller_type handType, nvr_keycode keyCode);
typedef bool (*API_NibiruController_IsButtonUp)(nvr_controller_type handType, nvr_keycode keyCode);
typedef bool (*API_NibiruController_IsButtonPressed)(nvr_controller_type handType, nvr_keycode keyCode);
typedef bool (*API_NibiruController_IsConnected)(nvr_controller_type handType);
typedef int  (*API_NibiruController_GetKeyState)(nvr_controller_type handType);
typedef int (*API_NibiruController_GetBatteryLevel)(nvr_controller_type handType);
typedef void (*API_NibiruController_Recenter)();

static std::string jstringTostring(JNIEnv* env, jstring jstr) {
	if (jstr == nullptr) {
		return "";
	}
	//转换成 char *
	const char *c_name0 = env->GetStringUTFChars(jstr, NULL);
	std::string str_name0 = c_name0;
	//释放引用
	env->ReleaseStringUTFChars(jstr, c_name0);
	return str_name0;
}

// 手柄接口

/**
 * 
 */
class NibiruImport
{
public:
	static bool Init();
	static void Uninit();
	
	static FString GetPluginDir();

	// 手柄接口
	static API_NibiruController_GetRotPos pAPI_NibiruController_GetRotPos;
	static API_NibiruController_IsTouchDown pAPI_NibiruController_IsTouchDown;
	static API_NibiruController_IsTouchUp pAPI_NibiruController_IsTouchUp;
	static API_NibiruController_IsTouchPressed pAPI_NibiruController_IsTouchPressed;
	static API_NibiruController_GetTouchPosition pAPI_NibiruController_GetTouchPosition;
	static API_NibiruController_IsButtonDown pAPI_NibiruController_IsButtonDown;
	static API_NibiruController_IsButtonUp pAPI_NibiruController_IsButtonUp;
    static API_NibiruController_IsButtonPressed pAPI_NibiruController_IsButtonPressed;
	static API_NibiruController_IsConnected pAPI_NibiruController_IsConnected;
	static API_NibiruController_GetKeyState pAPI_NibiruController_GetKeyState;
	static API_NibiruController_GetBatteryLevel pAPI_NibiruController_GetBatteryLevel;
	static API_NibiruController_Recenter pAPI_NibiruController_Recenter;
	// 手柄接口

	static API_NibiruInit pAPI_NibiruInit;
	static API_NibiruGetSensorData pAPI_NibiruGetSensorData;
	static API_NibiruGetSensorDataWithPosition pAPI_NibiruGetSensorDataWithPosition;
	static API_NibiruGetNVRConfig pAPI_NibiruGetNVRConfig;
	static API_NibiruResetHeadPose pAPI_NibiruResetHeadPose;
	static API_NibiruLockHeadPose pAPI_NibiruLockHeadPose;
	static API_NibiruUnLockHeadPose pAPI_NibiruUnLockHeadPose;
	static API_NibiruEnterVRMode pAPI_NibiruEnterVRMode;
	static API_NibiruLeaveVRMode pAPI_NibiruLeaveVRMode;
	static API_NibiruDestory pAPI_NibiruDestory;
	static API_NibiruGetFloatValue pAPI_NibiruGetFloatValue;
	static API_NibiruSetFloatValue pAPI_NibiruSetFloatValue;
	static API_NibiruGetIntValue pAPI_NibiruGetIntValue;
	static API_NibiruSetIntValue pAPI_NibiruSetIntValue;
	static API_NibiruGetParameter pAPI_NibiruGetParameter;
	static API_NibiruSetPatameter pAPI_NibiruSetPatameter;
	static API_NibiruComputeDistortedPoint pAPI_NibiruComputeDistortedPoint;
	static API_NibiruCreateTextures pAPI_NibiruCreateTextures;
	static API_NibiruSetTexture pAPI_NibiruSetTexture;

   	//===================== APIS =====================
	static nvr_init_info NibiruInit(int pluginVersion ,long pointer ,const nvrModeParms * parms );
	static nvr_mat4f NibiruGetSensorData(int *viewNumber);
	static nvr_mat4f NibiruGetSensorDataWithPosition(int *viewNumber, float* position);
	static bool DoesSupport6DofData();
	static void NibiruGetNVRConfig(float* profile);
	static void NibiruResetHeadPose();
	static void NibiruLockHeadPose();
	static void NibiruUnLockHeadPose();
	static void NibiruEnterVRMode(const nvrModeParms * params);
	static void NibiruLeaveVRMode();
	static void NibiruDestory();
	static float NibiruGetFloatValue(const char * property_name, float default_value);
	static bool NibiruSetFloatValue(const char * property_name, float value);
	// int
	static int NibiruGetIntValue(const char * property_name, int default_value);
	static bool NibiruSetIntValue(const char * property_name, int value);
	// 参数获取设置
	static char* NibiruGetParameter(const char * property_name);
	static bool  NibiruSetPatameter(const char * property_name, char* default_data);

	static void NibiruComputeDistortedPoint(const int32_t eye, const nvr_vec2f uv_in, nvr_vec2f uv_out[3]);
	// gen textures for double eyes
	static void NibiruCreateTextures(int* ids);
	// notify the texture has render ok
	static bool NibiruSetTexture(void * texture, int viewNum);


	//  手柄接口
	static void NibiruGetControllerRotPos(nvr_controller_type hand, float *dest, int length);
    static bool NibiruGetControllerTouchDown(nvr_controller_type handType);
    static bool NibiruGetControllerTouchUp(nvr_controller_type handType);
    static bool NibiruGetControllerTouchPressed(nvr_controller_type handType);
    static void NibiruGetControllerTouchPosition(nvr_controller_type handType, nvr_vec2f &position);
    static bool NibiruGetButtonDown(nvr_controller_type handType, nvr_keycode keyCode);
    static bool NibiruGetButtonUp(nvr_controller_type handType, nvr_keycode keyCode);
    static bool NibiruGetButtonPressed(nvr_controller_type handType, nvr_keycode keyCode);
    static bool NibiruIsControllerConnected(nvr_controller_type handType);
    static int  NibiruGetControllerKeyState(nvr_controller_type handType);
    static int  NibiruGetControllerBatteryLevel(nvr_controller_type handType);
    static void NibiruResetController();
	//  手柄接口
	//===================== APIS =====================



protected:
	static void FreeDependency(void*& Handle);
	static bool LoadDependency(const FString& Dir, const FString& Name, void*& Handle);

private:
	static void* GSharedLibraryHandle;
	static FString GPluginDir;


};
#endif